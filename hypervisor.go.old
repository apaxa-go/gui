package gui

import "github.com/apaxa-go/helper/mathh"

type upgTreeElement struct {
	c        Control
	recursive bool
	apply bool
	//parent   *upgTreeElement
	children []*upgTreeElement
}

func (e upgTreeElement)hasChild(c Control)int{
	for i,child:=range e.children{
		if child.c==c{
			return i
		}
	}
	return -1
}

func (e *upgTreeElement)add(e1 *upgTreeElement)bool{
	if e.c!=e1.c{
		return false
	}
	e0:=e
	for e0.c==e1.c{

	}
}

// Update Possible Hor(izontal)/Ver(tical) Geometry entry
/*type upg struct {
	control   Control
	recursive bool
}*/

type upgs map[Control]bool // true if recursive

func (d upgs)add(control Control, recursive bool){
	r,ok:=d[control]
	if !ok || (!r && recursive){
		d[control]=recursive
	}
}

func makeTreeForControl(control Control, recursive bool)(root *upgTreeElement){
	root=&upgTreeElement{control,recursive,true,nil}
	for root.c.Parent()!=nil{
		root=&upgTreeElement{root.c.Parent(),false,false,[]*upgTreeElement{root}}
	}
	return
}

func (d upgs)tree()(root *upgTreeElement){

}



// TODO split horGeometry to X&Width. verGeometry to Y&Height (because now shifting control without changing their width cause geometry recomputation which is unnecessary - only invalidateRect required)
type Hypervisor_OLD struct {
	pause  int
	window Window

	uphgs []upg         // UpdatePossibleHorGeometry requests
	uchgs []Control     // UpdateChildrenHorGeometry
	upvgs []upg         // UpdatePossibleVerGeometry requests
	ucvgs []Control     // UpdateChildrenVerGeometry
	irs   []BaseControl // InvalidateRegion requests
}

//
// State
//

func (h *Hypervisor_OLD) Pause() { h.pause++ }
func (h *Hypervisor_OLD) Resume() {
	h.pause = mathh.Max2Int(0, h.pause-1)
	h.runIfActive()
}
func (h *Hypervisor_OLD) Active() bool { return h.pause == 0 }

//
// Requests
//

func (h *Hypervisor_OLD) updatePossibleHorGeometry(control Control, recursive bool) {
	h.uphgs = append(h.uphgs, upg{control, recursive})
}

func (h *Hypervisor_OLD) UpdatePossibleHorGeometry(control Control, recursive bool) {
	h.updatePossibleHorGeometry(control, recursive)
	h.runIfActive()
}

func (h *Hypervisor_OLD) updateChildrenHorGeometry(control Control) {
	h.uchgs = append(h.uchgs, control)
}

func (h *Hypervisor_OLD) UpdateChildrenHorGeometry(control Control) {
	h.updateChildrenHorGeometry(control)
	h.runIfActive()
}

func (h *Hypervisor_OLD) updatePossibleVerGeometry(control Control, recursive bool) {
	h.uphgs = append(h.upvgs, upg{control, recursive})
}

func (h *Hypervisor_OLD) UpdatePossibleVerGeometry(control Control, recursive bool) {
	h.updatePossibleVerGeometry(control, recursive)
	h.runIfActive()
}

func (h *Hypervisor_OLD) updateChildrenVerGeometry(control Control) {
	h.ucvgs = append(h.ucvgs, control)
}

func (h *Hypervisor_OLD) UpdateChildrenVerGeometry(control Control) {
	h.updateChildrenVerGeometry(control)
	h.runIfActive()
}

func (h *Hypervisor_OLD) invalidateRegion(control BaseControl) {
	h.irs = append(h.irs, control)
}

func (h *Hypervisor_OLD) InvalidateRegion(control BaseControl) {
	h.invalidateRegion(control)
	h.runIfActive()
}

//
// Work
//

func (h *Hypervisor_OLD) runIfActive() {
	if h.Active() {
		h.do()
	}
}

func (h Hypervisor_OLD) HasWork() bool {
	return len(h.uphgs) > 0 || len(h.uchgs) > 0 || len(h.uphgs) > 0 || len(h.ucvgs) > 0 || len(h.irs) > 0
}

func (h *Hypervisor_OLD) do() {
	// Theoretically no loop required, but wrong Control implementation may do crazy things.
	for h.HasWork() {
		h.doUPHG()
		h.doUCHG()
		h.doUPVG()
		h.doUCVG()
		h.doIR()
	}
}

//
// Update Possible Horizontal Geometry
//

// From down to up.
func (h *Hypervisor_OLD) doUPHG() {
	switch len(h.uphgs) {
	case 0:
	case 1:
		h.doUPHGQuick(h.uphgs[0].control, h.uphgs[0].recursive)
		h.uphgs = h.uphgs[:0]
	default:
		// TODO
	}
}

// Perform quick UPHG if only one request exists.
// Force update "control" and optionally all children. And conditionally update "control"s parents.
func (h *Hypervisor_OLD) doUPHGQuick(control Control, recursive bool) {
	var changed bool
	if recursive {
		changed = h.doUPHGQuickRecursive(control)
	} else {
		changed = h.doUPHGQuickSingle(control)
	}
	control = control.Parent()
	for changed && control != nil {
		changed = h.doUPHGQuickSingle(control)
		control = control.Parent()
	}
}

func (h *Hypervisor_OLD) doUPHGQuickRecursive(root Control) (changed bool) {
	for _, child := range root.Children() {
		h.doUPHGQuickRecursive(child)
	}
	changed = h.doUPHGQuickSingle(root)
	return
}

func (h *Hypervisor_OLD) doUPHGQuickSingle(c Control) (changed bool) {
	changed = c.setPossibleHorGeometry(c.ComputePossibleHorGeometry())
	h.updateChildrenHorGeometry(c) // TODO make this conditionally
	return
}

//
// Update Child Hor Geometry
//

// From up to down.
func (h *Hypervisor_OLD) doUCHG() {
	switch len(h.uchgs) {
	case 0:
	case 1:
		h.doUCHGQuickRecursive(h.uchgs[0])
		h.uchgs = h.uchgs[:0]
	default:
		// TODO
	}
}

// Perform quick getUCHG if only one request exists.
func (h *Hypervisor_OLD) doUCHGQuickRecursive(c Control) {
	children := c.Children()
	lefts, rights := c.ComputeChildHorGeometry()
	for i, child := range children {
		changed := child.setHorGeometry(lefts[i], rights[i])
		if changed {
			h.doUCHGQuickRecursive(child) // TODO make this more conditionally
			h.updatePossibleVerGeometry(child, false)
			h.invalidateRegion(child)
		}
	}
}

//
// Update Possible Vertical Geometry
//

// From down to up.
func (h *Hypervisor_OLD) doUPVG() {
	switch len(h.upvgs) {
	case 0:
	case 1:
		h.doUPVGQuick(h.upvgs[0].control, h.upvgs[0].recursive)
		h.upvgs = h.upvgs[:0]
	default:
		// TODO
	}
}

// Perform quick getUPVG if only one request exists.
// Force update "control" and optionally all children. And conditionally update "control"s parents.
func (h *Hypervisor_OLD) doUPVGQuick(control Control, recursive bool) {
	var changed bool
	if recursive {
		changed = h.doUPVGQuickRecursive(control)
	} else {
		changed = h.doUPVGQuickSingle(control)
	}
	control = control.Parent()
	for changed && control != nil {
		changed = h.doUPVGQuickSingle(control)
		control = control.Parent()
	}
}

func (h *Hypervisor_OLD) doUPVGQuickRecursive(root Control) (changed bool) {
	for _, child := range root.Children() {
		h.doUPVGQuickRecursive(child)
	}
	changed = h.doUPVGQuickSingle(root)
	return
}

func (h *Hypervisor_OLD) doUPVGQuickSingle(c Control) (changed bool) {
	changed = c.setPossibleVerGeometry(c.ComputePossibleVerGeometry())
	h.updateChildrenVerGeometry(c) // TODO make this conditionally
	return
}

//
// Update Child Ver Geometry
//

// From up to down.
func (h *Hypervisor_OLD) doUCVG() {
	switch len(h.ucvgs) {
	case 0:
	case 1:
		h.doUCVGQuickRecursive(h.ucvgs[0])
		h.ucvgs = h.ucvgs[:0]
	default:
		// TODO
	}
}

// Perform quick getUCVG if only one request exists.
func (h *Hypervisor_OLD) doUCVGQuickRecursive(c Control) {
	children := c.Children()
	tops, bottoms := c.ComputeChildVerGeometry()
	for i, child := range children {
		changed := child.setVerGeometry(tops[i], bottoms[i])
		if changed {
			h.doUCVGQuickRecursive(child) // TODO make this more conditionally
			h.invalidateRegion(child)
		}
	}
}

//
// Invalidate Region
//

func (h *Hypervisor_OLD) doIR() {
	for _, control := range h.irs {
		h.window.InvalidateRegion(control.Geometry())
	}
	h.irs = h.irs[:0]
}

//
// Old
//

func (h *Hypervisor_OLD) UpdateChildHorGeometry(c Control) {
	if !h.Active() {
		// TODO
		return
	}

}
